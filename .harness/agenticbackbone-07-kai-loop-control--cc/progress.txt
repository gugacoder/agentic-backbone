# Progress — agenticbackbone-07-kai-loop-control--cc

## Current Status
2/6 features complete. F-001, F-002 passing. Next: F-003 (prepare-step-integration).

## Specs Path
D:\sources\codr.studio\cia-prime-care\agentic-backbone\apps\backbone\milestones\07-kai-loop-control

## Environment

- **Stack**: Node.js, TypeScript (ES2022, ESM), npm workspaces monorepo
- **Package**: `packages/kai-sdk` (workspace `@agentic-backbone/kai-sdk`)
- **Dependencies**: `ai` (Vercel AI SDK v4), `@ai-sdk/openai-compatible`, `zod`
- **Build**: `npm run build --workspace=packages/kai-sdk` (tsc)
- **Dev**: `npm run dev --workspace=packages/kai-sdk` (tsc --watch)
- **No test framework** — validação via build + critérios manuais

## Features

- [x] F-001 loop-control-types — Novos tipos (PrepareStepContext, PrepareStepResult, step_finish event, campos em KaiAgentOptions)
- [x] F-002 step-finish-events — Emissão de eventos step_finish via onStepFinish
- [ ] F-003 prepare-step-integration — Integração do callback prepareStep no streamText
- [ ] F-004 stop-when-integration — Implementação de stopWhen como condição de parada customizada
- [ ] F-005 public-exports — Atualizar index.ts com novos exports
- [ ] F-006 build-verification — Verificação final de build limpo e comportamento default preservado

## Architecture Decisions

1. **Backward compatibility total**: Sem prepareStep/stopWhen, o agente funciona identicamente ao antes
2. **Sem novas dependências**: Usa apenas APIs já disponíveis no Vercel AI SDK v4
3. **Arquivos alterados**: Apenas `types.ts`, `agent.ts`, `index.ts` em `packages/kai-sdk/src/`
4. **stopWhen via onStepFinish + AbortController**: streamText não tem stopWhen nativo; usar AbortController.abort() dentro do onStepFinish
5. **prepareStep EXISTE no streamText** como `experimental_prepareStep`: Recebe `{ stepNumber, stepCount }` e retorna `{ model?, toolChoice?, activeTools? }`. Kai wrapper traduz model string para openrouter() provider
6. **Eventos step_finish no generator**: fullStream já emite 'step-finish' events nativamente; capturá-los e traduzir para KaiAgentEvent
7. **prepareStep delega ao consumidor**: Sem abstração de routing — o consumidor decide a lógica

## Key API Findings

- `streamText` has `onStepFinish` (StepResult with toolCalls[].toolName, finishReason)
- `streamText` has `abortSignal` for cancellation
- `streamText` fullStream emits `step-finish` events with finishReason, usage
- `streamText` HAS `experimental_prepareStep` — receives `{ stepNumber, stepCount }`, returns `{ model?, toolChoice?, activeTools? }`
- `streamText` does NOT have `stopWhen` — use AbortController via onStepFinish

## Session Notes

- Session 1 (Initializer): Harness criado com 6 features (todas failing). PRP analisado, código existente explorado.
- Session 2: F-001 implementado. Adicionados PrepareStepContext, PrepareStepResult, step_finish event em KaiAgentEvent, stopWhen e prepareStep em KaiAgentOptions. Build limpo.
- Session 3: F-002 implementado. onStepFinish popula pendingStepEvents com step number, tool names, finishReason. fullStream loop drena esses eventos quando detecta 'step-finish' parts. Fallback drain no final do stream para edge cases. Build limpo.
